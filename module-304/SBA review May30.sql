select p.product.name, max(quantity_ordered) as max_offer, min(buy_price) as min_buy_price, avg_buy_price
from products p, orderdetails od
where p.id = od.products_id
group by od.product_id


-- for the sba

-- for this we can use the format function 
select p.product_name, format(max(quantity_ordered),2) as max_offer, format(min(quantity_ordered),2) as min_buy_price, 
format(round(avg(quantity_ordered),2),2) as avg_buy_price, count(*) as product_count
from products p, orderdetails od
where p.id = od.product_id
group by od.product_id;


-- transactionb important parts
-- 1 a transaction can include one of more inserts, update, or delete statements
-- 2 any changes made inside a transaction are not visible to other database users until you perform a commit
-- 3 commit is used to save the transaction
-- 4 rollback discards the changes in the transaction

-- understand what is an ambiguos column in the database
-- we did update statements and you need to know the format for the update statement

update <tablename> set <columnname> = <value> where ...
update * from offices;
update offices set address_line2 = 'unknown' where id = 8;

-- we know our basic aggregate functions - min, max, avg, count, sum

-- why is normalization important
-- 1 reduce data redundancy
-- 2 improve data integrity
-- 3 we want to simplify data maintenance
-- 4 (we have proper fk relationships and proper naming of tables and colums)
-- 5 ( we store data with a like measurement as in... we us feet, or inches but not both in the same column)

-- what statements is used to show distinct records ? -- distinct


-- anatomy of a select statement
-- select
-- from
-- where
-- group by
-- having
-- order by
-- limit


-- primary key

-- 1  can be used to identify a single unique record in a table
-- 2 by definition a primary key is unique and does not need additional configuration
-- 3 PRIMARY KEY CANNOT CONTAIN NULL VALUES!!!
	SELECT * from products where id is null; -- this will return 0 rows because the pk cannot be null
-- 4 the value of a primary key is automatically generated by using AUTO_INCREMENT (AI)

-- 5 a PK can consist of multiple columns -- this is a true statement even though you would never do it on the job

-- 6 is used to access database records faster -- pk is the fastest way to lookup a record in the database
-- 7 help maintain referential integrity
-- 8 pk should be - numeric, not null, auto incremented and unique

-- is null vs = null
select * from offices where address_line2=null; -- this will alwayus return 0 records because its not correct syntact
select * from offices where address_line2 is null; -- this will work properly
select * from offices where address_line2 is not null -- this will work properly   

-- thought processes
-- 1 identify the sub query and try to first think about what that sunquery will return
-- 2 then pay attention to the where clause for a double negative

-- what does the where clause do? ** 
-- defines one or more conditions that must be met for data to be returned

-- why do we use constraints on the database?
-- 1 limit the data that goes into the table -- for business requirements
-- 2 enhances data integrity


-- what do we know about joins?
-- 1 there is no known use for a cross join
-- 2 we know a self join is when you are connecting to the id column in the same table
-- 3 we we know that a non-equi-join is not even a real join
-- 4 we know that inner join can connect 2 or more tables ***

-- 5 this is a true statement - multiple types of joins can be used in the same query


-- what is the default order by - ascending


-- when adding an FK relationship which table do we add the FK relationship to?
-- let's consider products and orderdetails... which table has the FK?
-- it's the table with the 'many' sides of the relationship
-- it is NOT the table with the id side
-- the ALTER TABLE command with the ADD clause is needed to manually create a FK


-- a FK is not required for a database - they are good practice but you can create a database without using a FK

